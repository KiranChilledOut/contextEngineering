# Azure DevOps Pipeline for Blog Post Automation
# This pipeline builds, tests, and deploys the Function App

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - src/*
      - terraform/*
      - requirements.txt
      - host.json
      - .azure/*

pr:
  branches:
    include:
      - main
  paths:
    include:
      - src/*
      - terraform/*
      - requirements.txt
      - host.json
      - .azure/*

variables:
  # Build Variables
  pythonVersion: '3.11'
  functionAppName: 'func-blogpost-automation'
  
  # Environment Variables
  - group: blogpost-automation-dev # Variable group in Azure DevOps
  - name: terraformVersion
    value: '1.5.0'
  - name: resourceGroupName
    value: 'rg-blogpost-automation'

stages:
- stage: Build
  displayName: 'Build and Test'
  jobs:
  - job: BuildTest
    displayName: 'Build and Test Application'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: UsePythonVersion@0
      displayName: 'Use Python $(pythonVersion)'
      inputs:
        versionSpec: '$(pythonVersion)'
        addToPath: true
    
    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
      displayName: 'Install dependencies'
    
    - script: |
        python -m pytest tests/ --junitxml=junit/test-results.xml --cov=src --cov-report=xml --cov-report=html
      displayName: 'Run tests with coverage'
    
    - task: PublishTestResults@2
      displayName: 'Publish test results'
      inputs:
        testResultsFiles: '**/test-*.xml'
        testRunTitle: 'Python $(pythonVersion)'
      condition: succeededOrFailed()
    
    - task: PublishCodeCoverageResults@1
      displayName: 'Publish code coverage'
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: '$(System.DefaultWorkingDirectory)/**/coverage.xml'
        reportDirectory: '$(System.DefaultWorkingDirectory)/**/htmlcov'
    
    - script: |
        black --check src/ tests/
        isort --check-only src/ tests/
        flake8 src/ tests/
      displayName: 'Code quality checks'
    
    - script: |
        mypy src/
      displayName: 'Type checking'
      continueOnError: true
    
    - task: ArchiveFiles@2
      displayName: 'Archive function app'
      inputs:
        rootFolderOrFile: '$(System.DefaultWorkingDirectory)'
        includeRootFolder: false
        archiveType: zip
        archiveFile: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
        replaceExistingArchive: true
        verbose: true
        excludePaths: |
          venv/**
          .venv/**
          __pycache__/**
          *.pyc
          .git/**
          .gitignore
          .azure/**
          terraform/**
          tests/**
          htmlcov/**
          .coverage
          .mypy_cache/**
          .pytest_cache/**
    
    - publish: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
      artifact: drop
      displayName: 'Publish function app artifact'

- stage: Infrastructure
  displayName: 'Deploy Infrastructure'
  dependsOn: Build
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
  jobs:
  - deployment: DeployInfrastructure
    displayName: 'Deploy Terraform Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'blogpost-automation-dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: '$(terraformVersion)'
          
          - task: AzureCLI@2
            displayName: 'Terraform Init'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                cd terraform
                terraform init \
                  -backend-config="storage_account_name=$(terraformStorageAccount)" \
                  -backend-config="container_name=tfstate" \
                  -backend-config="key=blogpost-automation.tfstate" \
                  -backend-config="resource_group_name=$(terraformResourceGroup)"
          
          - task: AzureCLI@2
            displayName: 'Terraform Plan'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                cd terraform
                terraform plan \
                  -var="environment=$(environment)" \
                  -var="location=$(azureLocation)" \
                  -out=tfplan
          
          - task: AzureCLI@2
            displayName: 'Terraform Apply'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                cd terraform
                terraform apply -auto-approve tfplan
          
          - task: AzureCLI@2
            displayName: 'Set Pipeline Variables from Terraform Output'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                cd terraform
                FUNCTION_APP_NAME=$(terraform output -raw function_app_name)
                RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
                KEY_VAULT_URI=$(terraform output -raw key_vault_uri)
                
                echo "##vso[task.setvariable variable=functionAppName;isOutput=true]$FUNCTION_APP_NAME"
                echo "##vso[task.setvariable variable=resourceGroupName;isOutput=true]$RESOURCE_GROUP_NAME"
                echo "##vso[task.setvariable variable=keyVaultUri;isOutput=true]$KEY_VAULT_URI"
            name: terraformOutput

- stage: Deploy
  displayName: 'Deploy Function App'
  dependsOn: 
    - Build
    - Infrastructure
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
  variables:
    functionAppName: $[stageDependencies.Infrastructure.DeployInfrastructure.outputs['terraformOutput.functionAppName']]
    resourceGroupName: $[stageDependencies.Infrastructure.DeployInfrastructure.outputs['terraformOutput.resourceGroupName']]
    keyVaultUri: $[stageDependencies.Infrastructure.DeployInfrastructure.outputs['terraformOutput.keyVaultUri']]
  jobs:
  - deployment: DeployFunctionApp
    displayName: 'Deploy Function App'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'blogpost-automation-dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: drop
            displayName: 'Download function app artifact'
          
          - task: AzureFunctionApp@1
            displayName: 'Deploy Azure Function App'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: 'functionAppLinux'
              appName: '$(functionAppName)'
              resourceGroupName: '$(resourceGroupName)'
              package: '$(Pipeline.Workspace)/drop/$(Build.BuildId).zip'
              runtimeStack: 'PYTHON|3.11'
              deploymentMethod: 'zipDeploy'

- stage: IntegrationTests
  displayName: 'Integration Tests'
  dependsOn: Deploy
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
  jobs:
  - job: IntegrationTests
    displayName: 'Run Integration Tests'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: UsePythonVersion@0
      displayName: 'Use Python $(pythonVersion)'
      inputs:
        versionSpec: '$(pythonVersion)'
        addToPath: true
    
    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
      displayName: 'Install dependencies'
    
    - task: AzureCLI@2
      displayName: 'Run integration tests'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Get function app URL
          FUNCTION_APP_URL=$(az functionapp show --name $(functionAppName) --resource-group $(resourceGroupName) --query "defaultHostName" -o tsv)
          export FUNCTION_APP_URL="https://$FUNCTION_APP_URL"
          
          # Run integration tests
          python -m pytest tests/integration/ --junitxml=junit/integration-test-results.xml -v
      env:
        AZURE_SUBSCRIPTION_ID: $(subscriptionId)
        FUNCTION_APP_NAME: $(functionAppName)
        RESOURCE_GROUP_NAME: $(resourceGroupName)
    
    - task: PublishTestResults@2
      displayName: 'Publish integration test results'
      inputs:
        testResultsFiles: '**/integration-test-*.xml'
        testRunTitle: 'Integration Tests'
      condition: succeededOrFailed()

- stage: Production
  displayName: 'Production Deployment'
  dependsOn: IntegrationTests
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: ProductionDeployment
    displayName: 'Deploy to Production'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'blogpost-automation-prod'
    strategy:
      runOnce:
        deploy:
          steps:
          - script: echo "Production deployment would go here"
            displayName: 'Production deployment placeholder'
          # Add production-specific deployment steps here